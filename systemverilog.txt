# vim: ft=conf

#===============================================================
# data types
#===============================================================
bit [31:0] b32;     // 2-state, unsigned
reg [31:0] r32;     // 4-state, unsigned
logic [31:0] l32;   // 4-state, unsigned (reg and logic are synonym
int i;              // 2-state, signed, 32b
integer i;          // 4-state, signed, 32b
byte b8;            // 4-state, signed, 8b
shortint s;         // 4-state, signed, 16b
longint l;          // 4-state, signed, 64b
time t;             // 4-state, unsigned, 64b
real r;

$isunknown(my_var); // return 1 if one bit is X or Z

#------------------------------------------------------
# fixed-size arrays
#------------------------------------------------------
int arr[16];
arr = '{9, 4, default:-1};
for (int i=0; i<$size; i++) // both are equivalent
foreach (arr[j])            // both are equivalent

# multidimensional
int mult[2][3];
mult = '{'{0,1,2}, '{2,3,4}};
foreach (mult[i,j])             // both are equivalent
foreach (mult[i])               // both are equivalent
    foreach (mult[,j])

# packed array
bit [3:0] [7:0] barray [2];     // access [2], then [3:0], then [7:0]
barray[1]       = 32'hdeadbeef;
barray[1][0]    = 8'hff;
barray[1][0][7] = 1'b1;

#------------------------------------------------------
# dynamic arrays
#------------------------------------------------------
int dyn[];
dyn = new[5];           // allocate 5 new elements, old values are lost
dyn = new[100](dyn);    // allocate 100 new elements and copy
dyn.delete();

#------------------------------------------------------
# queues
#------------------------------------------------------
# no performance hit of dyn array that has to allocate a new array an copy the
# entire content

int q[$] = {0,1,3};
i = q[$];           // i=3
q.insert(4,2);      // q={0,1,4,3}
q.push_front(9);    // q={9,0,1,4,3}
j= q.pop_back();    // j=3; q={9,0,1,4]

#------------------------------------------------------
# associative arrays
#------------------------------------------------------
# model extremely large address space arrays
bit [31:0] assoc[int];
assoc.first(idx);   // get 1st index
assoc.next(idx);    // get 2nd index
assoc.delete(idx);  // delete idx element

#------------------------------------------------------
# array methods
#------------------------------------------------------
# reduction methods
int i;
bit arr [10] = '{1, 1, 1, default:0};
$display("%0d", arr.sum);                   // 1, since on 1 bit
$display("%0d", arr.sum with(int'(item)));  // 3, since on 32 bits
i = arr.sum;                                // 3, since on 32 bits (i is 32bits)

# other reduction are product, and, or, xor

# locator methods
int arr[4] = '{4,2,4,0};
int q[$];
q = arr.min();      // {0}
q = arr.max();      // {4}
q = arr.unique();   // {4,2,0}

q = arr.find with (item > 0);           // {4,2,4}
q = arr.find_first with (item < 3);     // {2}
q = arr.find_last  with (item > 4);     // {} not found
q = arr.find_index with (item > 3);     // {0,2}
q = arr.find_first_index with (item<3); // {1}
q = arr.find_last_index with (item<3);  // {2}

# sorting
arr.reverse();
arr.sort();
arr.rsort();
arr.shuffle();

#------------------------------------------------------
# streaming operators
#------------------------------------------------------
bit j[4] = '{8'ha, 8'hb, 8'hc, 8'hd};
int h;
h = { >> {j} }; // 0a0b0c0d
h = { << {j} }; // 0d0c0b0a

#------------------------------------------------------
# enum
#------------------------------------------------------
typedef enum {BAD=0, FIRST, SECOND=3, THIRD} ordinal_e; // must always start at 0
ordinal_e position;

# first, last, next and prev routines can be used on enum types

# $cast can be used to convert int to enum and enum to int (type checking),
# or static cast ordinal_e'(x) (no type checking)


#===============================================================
# procedural statement and routines
#===============================================================
# function can accept fork; my_task(); join_none; in systemverilog

#------------------------------------------------------
# ref
#------------------------------------------------------
# function and task can use ref args to copy pointer on the stack rather than copying an array
function void print_checksum (const ref bit [31:0] a[]);

# ref can only be used in routines with automatic storage

# using ref on a task output make a change on that output visible before task returns,
# useful for forks

# function can return an array but needs a typedef...
typedef int fixed_array5[5];
function fixed_array5 init(int start);

# ... easiest way is to use ref
function void init(ref int f[5], input int start);

#------------------------------------------------------
# automatic
#------------------------------------------------------
# as previously said, by default, all vars are static.
# use automatic to be able to call the same task concurently.
# it will fixed initialization bugs as well
automatic task foo;
  logic [7:0] b = add << 2; // bug if not automatic


#===============================================================
# connecting the testbench and design
#===============================================================
#------------------------------------------------------
# interface construct
#------------------------------------------------------
# interface signals should always be driven with non-blocking assignments
# interfaces should always be declared outside a module
# interfaces can only feature instances of other interfaces. No modules
#
# example:
interface arb_if(input bit clk);
  logic [1:0] grant, request;
  logic       rst;
endinterface

module arb (arb_if arbif);
...
always @(posedge arbif.clk or posedge arbif.rst)
begin
if (arbif.rst)
arbif.grant <= 2'b00;
else
arbif.grant <= next_grant;
...
end
endmodule

module top;
  bit clk;
  always #5 clk = ~clk;
  arb_if arbif(clk);
  arb a1 (arbif);
  test t1(arbif);
endmodule : top

# modport example:
interface arb_if(input bit clk);
  logic [1:0] grant, request;
  logic rst;
  modport TEST (output request, rst,
                input grant, clk);
  modport DUT (input request, rst, clk,
               output grant);
  modport MONITOR (input request, grant, rst, clk);
endinterface

module arb (arb_if.DUT arbif);
...
module test (arb_if.TEST arbif);
...

# clocking block:
#   - sync signals
#   - test bench won't change when clock is modified
interface arb_if(input bit clk);
  logic [1:0] grant, request;
  logic rst;

  clocking cb @(posedge clk);
    output request;
    input grant;
  endclocking

  modport TEST (output rst,
                clocking cb);
  modport DUT (input request, rst, clk,
               output grant);
  modport MONITOR (input request, grant, rst, clk);
endinterface

module test(arb_if.TEST arbif);
  initial
  begin
    arbif.cb.request <= 0;
    @arbif.cb;
    $display("grant=%0d", arb_if.cb.grant);
  end
endmodule

#------------------------------------------------------
# program
#------------------------------------------------------
# separate testbench timing from RTL timing to reduce race conditions
# cannot have hierarchy of instances of modules, interfaces or other programs
# cannot have always @
# simulation end when last statement of initial block inside program is done
program automatic test (arb_if.TEST arbif);
  ...
  initial begin
    arbif.cb.request <= 2'b01;
    $display("Drove req=2'b01");
    repeat (2) @arbif.cb;
    if (arbif.cb.grant != 2'b01)
      $display("grant !=2'b01");
  end
endprogram

# test should contained in 1 unique program
# use OOP to build dynamic hierarchical testbench instead of module
# should always use automatic to mimic C

#------------------------------------------------------
# clock
#------------------------------------------------------
# the clock should always be declared in a module like so:
module clock_generator(output bit clk);
  initial
    forever #5 clk = ~clk;
endmodule

#------------------------------------------------------
# systemverilog assertions (SVA)
#------------------------------------------------------
# immediate assertions
bus.cb.request <= 1'b1;
repeat (2) @bus.cb;
a1: assert (bus.cb.grant == 2'b01)
  granted ++;                   // not necessary customization
else                            // not necessary customization
  $display("Grant failed !");   // not necessary customization

# concurrent assertions: TODO


#===============================================================
# basic OOP
#===============================================================
# good practice: define them in a package
# good practice: separate declaration and construction

# a method in a class (task or function) uses automatic by default !

#------------------------------------------------------
# vocabulary
#------------------------------------------------------
#   - class: building block containing routines and variables
#   - object: instance of a class
#   - handle: pointer to an object
#   - property: variable that holds data
#   - method: task or function manipulating variables
#   - prototype: header of a routine

#------------------------------------------------------
# construction
#------------------------------------------------------
class Transaction;
  logic [31:0] addr, crc, data[8];

  function new(logic [31:0] a=3, d=5);
    addr = a;
    foreach (data[i])
      data[i] = d;
  endfunction
endclass

initial begin
  Transaction tr0, tr1, tr2;    // declare handles
  tr0 = new();                  // allocate object; handle references it
  tr1 = new(10);
  tr2 = new(10,20);
end

#------------------------------------------------------
# deallocation
#------------------------------------------------------
# systemverilog uses garbage collection:
#   once the last handle of an object no longer references it,
#   it releases the memory for that object
Transaction t;
t = new();      // allocate 1st object
t = new();      // allocate 2nd object, deallocate the 1st
t = null;       // deallocate the 2nd

#------------------------------------------------------
# difference with C/C++
#------------------------------------------------------
# SV does not allow any modification of a handle or using a handle
# of 1 type to refet to an object of another type

# because of its garbage collection (not manual), you can be sure
# that a handle is always pointing to a valid object

# public variable directly accessible by users is preferred to get()
# and put() method in SV

#------------------------------------------------------
# static variable in a class
#------------------------------------------------------
# to be used instead of a global variable
class Transaction;
  static int count = 0; // Number of objects created
  int id;               // Unique instance ID
  function new();
    id = count++;       // Set ID, bump count
  endfunction
endclass

Transaction t1, t2;
initial begin
  t1 = new();   // 1st instance, id=0, count=1
  t2 = new();   // 2nd instance, id=1, count=2
  $display("Second id=%d, count=%d", t2.id, t2.count);
  $display("How to access a static var: %d", Transaction::count);
end

#------------------------------------------------------
# static handle
#------------------------------------------------------
# avoid copying the same object multiple times
class Transaction;
  static Config cfg;

  function new();
    mode = cfg.mode;
  endfunction
endclass

Config cfg;
initial begin
  cfg = new(MODE_ON);
  Transaction::cfg = cfg;
  ...
end

#------------------------------------------------------
# static method
#------------------------------------------------------
# can also be used and defined like static variables,
# can only access args and/or static variables

#------------------------------------------------------
# defining method outside of class
#------------------------------------------------------
class Transaction;
  bit [31:0] addr, crc, data[8];
  extern function void display();
endclass

function void Transaction::display();
  ...
endfunction

#------------------------------------------------------
# passing object to function with ref
#------------------------------------------------------
# allow to modify object
# allow to save memory a it does not copy the object twice
function void create (ref Transaction tr);
  tr = new();
  tr.addr = 42;
endfunction

Transaction t;
initial begin
  create (t);
  $display(t.addr);
end

#------------------------------------------------------
# copying object
#------------------------------------------------------
# shallow copy: if Transaction contains a handle pointing to
# another object, src and dst will point to the same one !!!
Transaction src, dst;
initial begin
  src = new();      // create 1st object calling Transaction's new() if defined
  dst = new src;    // shallow copy of src
  dst.stats.startT = 96;
  $display(src.stats.startT);   // prints 96 !
end

# deep copy
class Transaction;
  bit [31:0] addr, crc, data[8];
  Statistics stats; // Handle points to Statistics object
  static int count = 0;
  int id;

  function new();
    stats = new();
    id = count++;
  endfunction

  function Transaction copy();
    copy = new();       // Construct destination object
    copy.addr = addr;   // Fill in data values
    copy.crc = crc;
    copy.data = data;
    copy.stats = stats.copy(); // Call Statistics::copy
  endfunction
endclass

class Statistics;
  time startT, stopT; // Transaction times
  ...
  function Statistics copy();
    copy = new();
    copy.startT = startT
    copy.stopT = stopT;
  endfunction
endclass

Transaction src, dst;
initial begin
  src = new();
  src.stats.startT = 42;
  dst = new src;    // uses copy()
  dst.stats.startT = 96;
end


#===============================================================
# randomization
#===============================================================
#------------------------------------------------------
# what to randomize
#------------------------------------------------------
# device configuration:         DUT config
# environment configuration:    config of other blocks
# primary input data:           main data
# encapsulated input data:      data inside the data
# protocol exceptions
# delays
# transaction status
# errors and violation

#------------------------------------------------------
# how to randomize
#------------------------------------------------------
# never randomize in the constructor
# all rand should be public

class Packet;
  // The random variables
  rand bit [31:0] src, dst, data[8];
  randc bit [7:0] kind;
  // Limit the values for src
  constraint c {src > 10;
                src < 15;}
endclass

Packet p;
initial begin
  p = new();// Create a packet
  assert (p.randomize())
  else $fatal(0, "Packet::randomize failed");
  transmit(p);
end

#------------------------------------------------------
# constraints
#------------------------------------------------------
class Packet;
  ...
  rand bit [6:0] b;
  rand bit [5:0] e;
  rand int c,f;
  int fib[6] = '{1,1,2,3,5,8};
  typedef enum {SUN, MON, TUE, WED, THU, FRI, SAT} days_e;
  days_e choices[$];
  rand dayes_e choice;

  constraint constr {
    lo < med; // max is 1 relational...
    med < hi; // ...operator per line
    foo inside {[-100:100]};
    bar dist {0:=40, [1:3]:=60};    // 0: weight=40/220
    bor dist {0:/40, [1:3]:/60};    // 0: weight=40/100
    b inside {[$:4], [20:$]};       // 0<=b<=4 || 20<=b<=127
    e inside {[$:4], [20:$]};       // 0<=e<=4 || 20<=e<=63
    !(c inside {[lo:hi]};           // c<lo || c>hi
    f inside fib;                   // 1 has the same weight as other member of fib
    choice inside choices;          // dynamic
  }

  constraint c_external;
endclass

Packet p;
initial begin
  Packet::c_external { length == 1;}
  p = new;
  p.choices = {Packet::TUE, Packet::THU};
  assert (p.randomize());
  $display("day is %s", p.choice.name());   // name return string of enum value name
  p.choices = {Packet::MON, Packet::WED, Packet::FRI};
  assert (p.randomize());
  $display("day is %s", p.choice.name());   // name return string of enum value name
end

# contraints are not procedural code: it is not read from top to bottom
# contraints are declarative code: all active at the same time
# contraints are bidirectional (even if-else):
#   - constraints are solved concurrently
#   - adding or removing constrain of 1 var affect all var that are directly or indirectly related

# constraints arithmetic: avoid '*' '/' and '%'

# constraint solver depends on simulator, SV does not guarantee the exact solution,
# you influence distribution with solve 'x' before 'y';
class Foo;
  rand bit x;
  rand bit y;
  constraint c {
    (x==0) -> y==0;
    solve x before y;
  }
endclass
# x before y gives the following (x,y) repartition:
# (0,0)     x before y: 1/2     y before x: 1/4
# (0,1)     x before y: 0       y before x: 0
# (1,0)     x before y: 1/4     y before x: 1/4
# (1,1)     x before y: 1/4     y before x: 1/2

# enable/disable constraints
Packet p;
initial begin
  p = new();
  p.constraint_mode(0);                     // disable all; by default they are all enabled
  p.valid_constraint.constraint_mode(1);    // enable the most permissive constraint
  assert(p.randomize());
  ...
  assert(p.randomize() with {addr >=50; data<10;}); // in-line constraint
end

#------------------------------------------------------
# other random functions
#------------------------------------------------------
# function void pre_randomize() and post_randomize() are run before and after randomize(),
# they only accept function inside

# $random           : flat dist,return  signed 32b
# $urandom          : flat dist,return  unsigned 32b
# $urandom_range    : flat dist over a range
# $dist_exponential : exponential decay
# $dist_normal
# $dist_poisson
# $dist_uniform

# disable randomization of 1 var
p.foo.rand_mode(0);
p.foo = 42;
assert(p.randomize());

# check object satisfy constraints after modifications
assert(p.randomize());
p.bar = 56;
assert(p.randomize(null));  # don't randomize, just check if bar=56 is legal

# randomize only 1 var
assert(p.randomize(foo));   # only randomize foo

# randcase
initial begin
  int len;
  randcase
    1: len = $urandom_range(0,2);
    8: len = $urandom_range(1,2);
    1: len = $urandom_range(5,8);
  endcase
end

#------------------------------------------------------
# array randomization
#------------------------------------------------------
class DynSize;
  rand logic [31:0] d[];
  constraint d_size {d.size() inside {[1:10]};}
endclass

# strobe.sum() would be on 1b if not compared to 4b
class StrobePat;
  rand bit strobe[10];
  constraint c_set_four { strobe.sum() == 4'h4; }
endclass

class GoodSum;
  rand uint len[];
  constraint c_len {
    foreach (len[i])
      len[i] inside {[1:255]};
    len.sum < 1024;
    len.size() inside {[1:8]};
  }
endclass

class Ascend;
  rand uint d[10];
  constraint c {
    foreach (d[i])
      if (i>0)
        d[i]>d[i-1];
  }
endclass

# array of handles: need to allocate all the element before randomization
class RandStuff
  rand int value;
endclass

class RandArray;
  rand RandStuff array[];

  constraint c {array.size() inside {[1:10]};}

  function new();
    array = new[10];    // allocate max size
    foreach (array[i])
      array[i] = new();
  endfunction
endclass

RandArray ra;
initial begin
  ra = new();
  assert(ra.randomize());
  foreach (ra.array[i])
   $display(ra.array[i].value);
end

#------------------------------------------------------
# sequences
#------------------------------------------------------
# to generate a sequence a multiple transaction, the best option
# is to use an array of handle pointing on transactions

# the use of "randsequence" is not encouraged

#------------------------------------------------------
# random number generator (PRNG)
#------------------------------------------------------
# verilog has a single PRNG: a new rand to compute in a class
# would affect other class

# systemverilog has a PRNG per object and thread: with the same seed,
# the same object will be the same if its class did not change


#===============================================================
# threads and interprocess communication (IPC)
#===============================================================
# fork...join; fork...join_any; fork...join_none

# a class constructor should initialize values, not start any thread

# classic automatic fork...join_none bug:
initial begin
  for (int j=0; j<3; j++)
    fork
      automatic int k = j;
      $display(k);
    join_none
  wait fork;
end

#------------------------------------------------------
# disable threads
#------------------------------------------------------
# disable fork
initial begin
  fork begin    // needed to limit scope of disable fork
    // forks and threads
    // wait something
    disable fork;
  end join      // needed to limit scope of disable fork
end

# disable label
initial begin
  fork    // th0
  begin : threads_inner
    check_trans(tr1); // th1
    check_trans(tr2); // th2
  end
  // Stop th[12] but leave th0 alone
  #(TIME_OUT/2) disable threads_inner;
  join
end

# disable a task
task automatic wait_for_timeout(int id);
  fork
    if (id == 0)
      #2 disable wait_for_timeout;
  join_none
  fork
    #10 $display("%m done");
  join_none
endtask
initial begin
  wait_for_timeout(0);
  wait_for_timeout(1);
  wait_for_timeout(2);
  // none of them will display done, id0 kills
  // all wait_for_timeout() in all threads
end

#------------------------------------------------------
# IPC: events
#------------------------------------------------------
# events are zero-width pulse

# -> and @
event e1, e2;
initial begin
  $display("1: before");
  -> e1;
  @e2;
  $display("1: after");
end
initial begin
  $display("2: before");
  -> e2;
  @e1;
  $display("2: after");
end
# displays:
#   1: before
#   2: before
#   1: after

# wait(e.triggered());
event e1, e2;
initial begin
  $display("1: before");
  -> e1;
  wait(e2.triggered());
  $display("1: after");
end
initial begin
  $display("2: before");
  -> e2;
  wait(e1.triggered());
  $display("2: after");
end
# displays:
#   1: before
#   2: before
#   1: after
#   2: after

# events in loop
forever begin
  // this is a zero delay loop !!!
  wait(handshake.triggered());
  process_in_zero_time();
end
forever begin
  wait(handshake.triggered());
  $display("foo");  // this fixes it
  process_in_zero_time();
end

# events can be passed to classes and routines
class Gen;
  event done;
  function new(event done);
    this.done = done;
  endfunction

  task run();
    // do stuff
    -> done;
  endtask
endclass

event gen_done;
Gen gen;
initial begin
  gen = new(gen_done);
  wait(gen_done.triggered());
end

# waiting for multiple events
foreach (gen[i]) begin
  fork
    automatic int k = i;
    wait(done[k].triggered());
  join_none
end
wait fork;

# waiting on static var is easier
class Gen;
  static int th_cnt = 0;
  task run();
    th_cnt++;
    fork
      begin
        // do stuff
        th_cnt--;
      end
    join_none
  endtask
endclass

initial begin
  foreach (gen[i])
    gen[i] = new();
  foreach (gen[i])
    gen[i] = run();
  wait(Gen::th_cnt == 0);
end

#------------------------------------------------------
# IPC: semaphores
#------------------------------------------------------
# new(n), get(n), put(n)
# try_get(n): do not block, returns 1 if enough keys, 0 otherwise
semaphore sem;
initial begin
  sem = new(1);
  fork
    foo();
    foo();
  join
end

task foo();
  sem.get(1);
  // do stuff
  sem.put(1);
endtask

#------------------------------------------------------
# IPC: mailbox
#------------------------------------------------------
# fifo to put whatever type inside
# typically: "generator" ========> "driver"

# function are new(), put(h), get(h)
# peek(h): create a copy of h, but does not remove it
# try_peek(h), try_get(h): non blocking
# calling new(n) will limit mailbox size to n

class Generator;
  Transaction tr;
  mailbox mbx;

  function new(mailbox mbx);
    this.mbx = mbx;
  endfunction

  task run(int count);
    repeat (count) begin
      tr = new();   // allocate object in the loop, not outside
      assert(tr.randomize());
      mbx.put(tr);
    end
  endtask
endclass

class Driver;
  Transaction tr;
  mailbox mbx;

  function new(mailbox mbx);
    this.mbx = mbx;
  endfunction

  task run(int count);
    repeat (count) begin
      mbx.get(tr);
      ...
    end
  endtask
endclass

program automatic mailbox_example(bus_if.TB bus,...);
`include "transaction.sv"
`include "generator.sv"
`include "driver.sv"

  mailbox mbx;
  Generator gen;
  Driver drv;
  int count;

  initial begin
    count = $urandom_range(50);
    mbx = new();
    gen = new(mbx);
    drv = new(mbx);
    fork
      gen.run(count);
      drv.run(count);
    join
  end
endprogram

# right now the Generator and Driver are not in sync,
# we can use bounded mailboxes and peek() to add sync
class Consumer;
  mailbox mbx;
  task run();
    int i;
    repeat(3) begin
      mbx.peek(i);
      // do stuff
      mbx.get(i);
    end
endclass

initial begin
  mbx = new(1);
  p = new();
  c = new();

  fork
    p.run();
    c.run();
  join
end

# sync can also be achieved using events or 2 mailboxes
